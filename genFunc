#!/bin/bash

	SD () {

		local ax long low high
	
		ax=$(index $(getLat disp | sort -n | tail -1) "$(getLat disp)")
		long=$(getLat disp | sort -n | tail -1)
		low=$1
		high=$2

		python3.7 - $ax $long $low $high <<- END

			from sys import argv
	
			axis = int(argv[1])
			l, low, high = [float(i) for i in argv[2:]]
			coordType = 'Cartesian'
  
			with open('POSCAR', 'r') as f, open('SD', 'w') as g:

			  for line in range(5): 
			    g.write(f.readline())
   
			  atoms = f.readline(); g.write(atoms); atoms = atoms.split()
			  nums = f.readline(); g.write(nums); nums = nums.split()
			  g.write('SD\n')
			  g.write(f.readline())

			  for s in range(len(nums)):
        
			    lines = [[float(value) for value in f.readline().split()] for line in range(int(nums[s]))]
        
			    for line in sorted(lines, key=lambda line: line[axis]):
			      SD = ' F F F' if low * l < line[axis] < high * l else ' T T T'
			      g.write('%18.9f %18.9f %18.9f' % tuple(line) + SD + ' \n')

		END

		mv SD POSCAR

  }

	clip () {
		if [[ $# < 2 ]]; then
			echo -e "\nUSAGE: clip <s(start) | e(end) | b(both)> <# of lines> *<file name>\n"
		else
			if [[ $3 ]]; then file=$3; else file=''; fi
			case $1 in
				s) tail -n +$(($2+1)) $file ;;
				e) head -n -$2 $3 ;;
				b) tail -n +$(($2+1)) $file | head -n -$2 ;;
			esac
    fi
  }

	bandDecomp () {

		local name path rType range c

		run () {
			if [ $1 == 1 ]; then
				echo -ne "\nEnter range name -> "; read name; path=charge/$name
				mkdir -p $path; if [ ! -d charge ]; then echo -e "\nFailed to create necessary folders\n"; return; fi
				cp INCAR POSCAR POTCAR KPOINTS WAVECAR CHG* job $path
    	  sed -i "s/\(\-J\).*/\1 $name/" $path/job; tLim 2 5 $path/job
      	echo -e "mv PARCHG ../$name.vasp; rm CHG* WAVECAR" >> $path/job
				echo -n "Enter range type ( 0: energy | 1: bands ) -> "; read rType; set ${rType:=0}
				echo -n "Enter range -> "; read range
				if [[ $rType == 0 ]]; then 
					rType=EINT; range=$(float $range)
				else
					rType=IBAND
				fi
				disTag IBAND EINT; enbTag $rType; range=$(joinStr , $range)
				setTag "$rType LPARD ISTART LWAVE LCHARG" "$range T 1 F F" $path
				sbatch -D $path $path/job
				echo -ne "\nProcess another range? ( 1: yes | 0: no ) -> "; read c; set ${c:=0}; run $c
			else
				return
			fi
		}
		run 1
  }

	float () {
		local a
		for i in $*; do
			a=(${a[*]} $(echo "$i * 1.0" | bc))
		done
		echo "${a[*]}"
  }

	plot () {
    if [[ ! $1 ]]; then
			echo -e "\nUsage: plot <type> <loc>\n"
		elif [[ $1 == edit ]]; then
      vi /work/01293/hudamn/Edan/files/plot.py
    else
      python3.7 /work/01293/hudamn/Edan/files/plot.py ${@:1}; echo ""
    fi
  }

	waveFind () {

		local d

		if [[ $1 == d ]]; then d=-delete; fi
		eval "find -name WAVECAR -not -empty $d"
  }

  getChgDen () {
  
		local n nIon i paw j pos
  
    mkdir charge 2>/dev/null
    if [ ! -d charge ]; then
      echo -e "\nFailed creating folder\n"
    elif [[ ! $(grep "\-J" job | grep SP) ]]; then
			echo -e "\nMissing SP job file\n"
		else
      cp POSCAR POTCAR INCAR SCF_KPOINTS job charge; cd charge
			if [[ $(grep PAW_PBE POTCAR) ]]; then paw=2; else paw=0; fi
	  	s=($(storePos s)); n=($(storePos n)); nIon=$(storePos i)
      mkdir -p ${s[*]}; cat POSCAR | head -$((nIon + 8)) > tempPos; mv SCF_KPOINTS KPOINTS; queue 1
	
			j=1
	  	for i in ${!s[*]}; do
				pos=$((8 + j))
				sed -n "$pos,$((pos + ${n[$i]} - 1))p;1,8p" tempPos > POSCAR
				j=$((j + ${n[$i]}))
				sed -i -e "6s/.*/   ${s[$i]}/" -e "7s/.*/   ${n[$i]}/" POSCAR
				sed -i -e "s/^\(\#SBATCH -J \).*/\1${s[$i]}/" -e 's/accurate T 2/accurate F 2/' job
				potGen $paw ${s[$i]}; cp INCAR POSCAR POTCAR KPOINTS job ${s[$i]}
				sbatch -D ${s[$i]} job; mv ${s[$i]}/CHGCAR ${s[$i]}.vasp
	  	done

			mv tempPos POSCAR; rm INCAR POTCAR KPOINTS job; cd ../
    fi
  }

	vbm () {

		local nElect vbmI vbm cbm

  	nElect=$(head -6 EIGENVAL | tail -1 | getNumber | head -1); if (( nElect % 2 != 0 )); then ((nElect++)); fi
		if [[ $(head -9 EIGENVAL | tail -1 | rmSpace | wc -w) == 3 ]]; then col='2'; else col='2,3'; fi
		
		vbmI=$((nElect / 2))
   	vbm=($(tail -n +8 EIGENVAL | grep " $vbmI " | rmSpace | cut -d ' ' -f $col | sort -n | tail -1))
   	cbm=($(tail -n +8 EIGENVAL | grep " $((vbmI+1)) " | rmSpace | cut -d ' ' -f $col | sort -nr | tail -1))

	  case $1 in
			i) echo $vbmI ;;
			eV) echo ${vbm[*]} ;;
			eC) echo ${cbm[*]} ;;
			*) echo -e "\nUsage: vbm <i: index | eV: vbm energies | eC: cbm energies>\n"
		esac	

  }

	occCheck () {

		local vbm cbm patV patC n nElect

		if [ ! -f EIGENVAL ]; then echo -e '\nNo EIGENVAL file found\n'; return; fi

		nElect=$(head -6 EIGENVAL | tail -1 | getNumber | head -1); vbm=$(vbm i)
		if [ $1 ]; then 
			if [[ $(head -9 EIGENVAL | tail -1 | rmSpace | wc -w) == 3 ]]; then
				if (( nElect % 2 != 0 )); then patV=0.500000; else patV=1.000000; fi; patC=0.000000
    	else
      	if (( nElect % 2 != 0 )); then patV='1.000000 0.000000'; else patV='1.000000 1.000000'; fi; patC='0.000000 0.000000'
    	fi
			n=$(head -6 EIGENVAL | tail -1 | rmSpace | cut -d ' ' -f 2)
    	if [[ $(grep " $vbm " EIGENVAL | rmSpace | grep "$patV" | wc -l) == $n ]] && \
         [[ $(grep " $((vbm+1)) " EIGENVAL | rmSpace | grep "$patC" | wc -l) == $n ]]; then echo ''; else echo '*'; fi
		else
			grep -C 1 " $vbm " EIGENVAL
		fi
	}

	backUp () {
		if [ ! $1 ]; then
			echo -e "\nUsage: backUp <jobType> <args>\n"
		else
			case $1 in
				IN) mkdir -p output/init/$2; cp INCAR KPOINTS POSCAR OUTCAR EIGENVAL Vasp.out status output/init/$2 ;;
				R) 	mkdir -p output/relax/$2; cp INCAR POSCAR OUTCAR EIGENVAL XDATCAR Vasp.out output/relax/$2 ;;
				V) 	mkdir -p output/relax/EV/$2; cp INCAR POSCAR OUTCAR EIGENVAL XDATCAR Vasp.out output/relax/EV/$2 ;;
				C) 	mkdir -p output/sigma/$2/$3/$4; cp EIGENVAL OUTCAR Vasp.out output/sigma/$2/$3/$4 ;;
				SP) mkdir -p output/sp/$2; cp INCAR EIGENVAL OUTCAR Vasp.out vasprun.xml output/sp/$2 ;;
				D) 	mkdir -p output/dos/$2; cp INCAR POTCAR OUTCAR DOSCAR EIGENVAL Vasp.out output/dos/$2
						cp vasprun.xml output/dos/$2/dos.xml ;;
				B) 	mkdir -p output/$2; cp INCAR EIGENVAL KPOINTS OUTCAR output/$2; cp vasprun.xml output/$2/bands.xml;;
			esac
		fi
  }

	math () {

		if [ ! $1 ]; then
  		echo -e "\nUsage: math <avg sum min max ceil floor triProd> \"<args>\"\n"
		elif [[ ! $2 ]]; then
			echo -e "\nEmpty argument list\n"
		else
			python3.7 - $1 "${@:2}" <<- END
			from sys import argv
			import numpy as np
			
			if argv[1] == 'avg': 
			  print(round(np.average([float(i) for i in argv[2:]]), 3))
			elif argv[1] == 'sum':
			  print(round(np.sum([float(i) for i in argv[2:]]), 3))
			elif argv[1] == 'min':
			  print(round(np.min([float(i) for i in argv[2:]]), 3))
			elif argv[1] == 'max':
			  print(round(np.max([float(i) for i in argv[2:]]), 3))
			elif argv[1] == 'ceil':
			  print(int(np.ceil([float(i) for i in argv[2:]])[0]))
			elif argv[1] == 'floor':
			  print(int(np.floor([float(i) for i in argv[2:]])[0]))
			elif argv[1] == 'triProd':
			  v = [np.array([float(j) for j in argv[2+i:5+i]]) for i in (0, 3, 6)]
			  if len(v) == 3:
			    print(np.dot(v[0], np.cross(v[1], v[2])))
			END
		fi

  }

	oxyCore () {
		local c a path
		if [ $1 ]; then 
			path=$1
		elif [ -d OUTCAR ] && [ -f vasprun.xml ] || [ -f bands.xml ]; then 
			path=./
		else
			echo -e "\n -> Missing files...\n"; return
		fi
		file=$(find $1/*.xml)
		c=$(grep ' <rc><c>O </c><c> ' $file | wc -l)
		a=($(grep 1s $path/OUTCAR | tail -$c | rmSpace | cut -d ' ' -f 3))
		if [ ${#a[*]} != 0 ]; then 
			echo -e "\n Avg O 1s = $(math avg ${a[*]}) eV\n"
		else 
			echo -e "\n -> No 1s states available...\n"
		fi
  } 

  goto () {
		local dir
		echo -ne "\nSelect directory ( 1: BiVO4-V2O5 ) -> "; read dir
    case $dir in
			1) cd /work/01293/hudamn/stampede2/EDAN/interfaces/BiVO4-V2O5 ;;
      *) cd /work/01293/hudamn/stampede2/EDAN/ ;;
		esac
		echo ''
  }

  makeSuper () {
		if (( $# != 3 )); then 
			echo -e "\nUsage: makeSuper n m l (n m l are multiples of lattice parameters A B C)\n"
		else
			cp POSCAR unitCell
			python3.7 - $* <<- END
			from sys import argv
			from pymatgen.core.structure import Structure
			from pymatgen.io.vasp.inputs import Poscar			

			st = Structure.from_file('POSCAR')
			st.make_supercell(argv[1:])

			Poscar(st).write_file('POSCAR')
			END
		fi
  }

	highSymK () {
		local x
		python3.7 - "$*" <<- END
		from sys import argv
		from numpy.linalg import norm

		from pymatgen.core.structure import Structure
		from pymatgen.symmetry.analyzer import SpacegroupAnalyzer as sga
		from pymatgen.symmetry.bandstructure import HighSymmKpath

		args = [0.01, 0., 0.]
		for i, arg in enumerate(argv[1].split()): 
		  args[i] = float(arg)

		symprec, angTol, absTol = args

		st = Structure.from_file('POSCAR')
		st_sym = sga(st,symprec,angTol)
		ibz = HighSymmKpath(st,symprec,angTol,absTol)
		rec = st.lattice.reciprocal_lattice

		print("\nLattice details:")
		print("----------------")
		print("lattice type : {0}".format(st_sym.get_lattice_type()))
		print("space group  : {0} ({1})".format(st_sym.get_space_group_symbol(),
                                        st_sym.get_space_group_number()))

		print("\nList of high symmetry k-points: (2pi)")
		print("-------------------------------")
		print("                 b1     b2     b3         1/a1   1/a2   1/a3")
		for i, item in enumerate(ibz.kpath["kpoints"].items()):
    	kf = "["+' '.join(['{0:6.3f}'.format(j) for j in item[1]])+" ]"
    	kc = rec.get_cartesian_coords(item[1])
    	if not item[0] == '\Gamma': kc /= max(abs(kc))
    	kc = "["+' '.join(['{0:6.3f}'.format(j) for j in kc])+" ]"
    	print("%2d -> %6s | %s | %s" % (i, str(item[0]), kf, kc))
		END
		echo ''
  }

  genSymK () {
		if [ $1 ]; then
			vi /work/01293/hudamn/Edan/files/makeKpoints.py
		else
    	if [ ! -f SCF_KPOINTS ] && [ -f KPOINTS ]; then cp KPOINTS SCF_KPOINTS; fi
    	python3.7 /work/01293/hudamn/Edan/files/makeKpoints.py 
    	echo ""
		fi
  }

  dispFunc() { # display all available user-defined functions
    echo ""; grep '^  [A-Za-z][A-Za-z]* ()' /work/01293/hudamn/Edan/genFunc; echo ""
  }

  rmSpace () { # removes extra whitespace including tabs
    sed -e 's/  */ /g' -e "s/\t/ /g" -e 's/^ //'
  }

  joinStr () { # Usage: joinStr <delimiter> <args> 
		IFS=$1
    local args
		args=$*
    echo "${args[*]:2}"
  }
  
  getNumber () {
    grep -o "\-*[0-9][0-9]*\.*[0-9]*"
  }

  range () { # Usage: range <upper bound>
		local rng ind
    rng=()
    if [ $2 ]; then ind=$2; else ind=0; fi
    while (( $ind < $1 )); do
      rng+=($ind); ((ind++))
    done
    echo ${rng[*]}
  }

	index () { # return index of element in array
		local a i
		a=($2); for i in ${!a[*]}; do if [[ ${a[$i]} == $1 ]]; then echo $i; fi; done
  }

  inArray () { # Usage: inArray <var/str> <"array">
		local i
    for i in $2; do if [[ $i == $1 ]]; then echo 1; fi; done
  }

  getPrimitive () {
    if [ ! -f POSCAR ]; then
      echo -e "\nNo POSCAR found in current directory\n"; return
    else
      if [ -f fullPOS ]; then cp fullPOS POSCAR; fi
      cp POSCAR fullPOS

		python3.7 <<- END
		from pymatgen.core.structure import Structure
		from pymatgen.symmetry.analyzer import SpacegroupAnalyzer as sga
		from pymatgen.io.vasp.inputs import Poscar

		st = Structure.from_file('POSCAR')

		Poscar(sga(st).get_primitive_standard_structure(international_monoclinic=False)).write_file('POSCAR')

		END
			echo ""; cat POSCAR; echo -e "\n -> written to POSCAR...\n"
    fi
  }

  genMovie () { # Usage: genMovie <space-separated list of relaxation trial numbers> 
		local dir str files i
    dir="output/relax"
    str=$(joinStr , $*)
    files=($(find $dir/trial_[$str]/*/XDATCAR))
    cat ${files[0]} > xDat
    for i in ${files[*]:1}; do
      tail -n +8 $i >> xDat
    done
    cat $(find $dir/trial_[$str]/*/OUTCAR) | grep "energy  without entropy" > xOut
    cat $(find $dir/trial_[$str]/*/OUTCAR) | grep FORCES >> xOut
    /work/01293/hudamn/Edan/files/extra/xdat2xyz.pl
    rm xDat xOut
  }

  duplicateLines () {
		local n prev
    n=0
		cat $1 | while read line; do
      if (( n > 0 )); then
        if [ ! "$line" == "$prev" ]; then echo $line; fi;
      else
        echo $line
      fi
      prev="$line"
      ((n++))
    done > $1_temp
    mv $1_temp $1
  }

  kList () { # Usage: kList <dir>
		local folder file
    if [ ! $1 ] || [ ! -d $1 ]; then echo -e "\nMissing path!\n"; return; else folder=$1; fi
		file=$(find *.xml)
    sed -n '/kpointlist/,/weights/p' $folder/$file | grep '<v>' | \
    rmSpace | cut -d ' ' -f 2-4 | xargs printf "%0.6f %0.6f %0.6f\n" > kList; duplicateLines kList
  }

  bandEdges () { # obtain band edges for selected spin (provide any argument to print band edges)
	
		local s col vbmI cbmI vbm cbm eV kV kVn eC kC kCn

    kList ./

		vbmI=$(vbm i); cbmI=$((vbmI+1)); vbm=($(vbm eV)); cbm=($(vbm eC))

		if [ $1 ]; then s=$1; else echo -ne "\nSpin ( 1-up | 2-down ) -> "; read s; fi; if [[ ! $s =~ ^[12]$ ]]; then s=1; fi; echo ''

		eV=${vbm[$((s-1))]}
    kV=$(tail -n +8 EIGENVAL | rmSpace | grep -B $vbmI "$vbmI $(if (( s == 2 )); then echo ".* "; fi)$eV" | \
         head -1 | cut -d ' ' -f 1-3 | xargs printf "%0.6f ")
		kV=$(for i in $(echo $kV | cut -d ' ' -f 1-); do if [[ $i == -0.000000 ]]; then \
				echo -n '0.000000 '; else echo -n "$i "; fi;done)
    kVn=$(grep -n -- "^$( echo $kV)" kList | cut -d ':' -f 1 | head -1)
		eC=${cbm[$((s-1))]}
    kC=$(tail -n +8 EIGENVAL | rmSpace | grep -B $cbmI "$cbmI $(if (( s == 2 )); then echo ".* "; fi)$eC" | \
         head -1 | cut -d ' ' -f 1-3 | xargs printf "%0.6f ")
    kCn=$(grep -n -- "^$(echo $kC)" kList | cut -d ':' -f 1 | head -1)
    if (( s == 1 )); then echo -e "Spin Up\n"; else echo -e "Spin Down\n"; fi
    printf "  VBM: %0.3f eV @ %d [ %s]\n" $eV $kVn "$kV"
    printf "  CBM: %0.3f eV @ %d [ %s]\n" $eC $kCn "$kC"
    printf "  Gap: %0.3f eV\n" $(echo $eC - $eV | bc)
    echo ""
  }

  emc () {
		local k band spin st step
		if [[ $1 == 1 ]]; then
			echo -ne "\nK-point -> "; read k
			if [[ ! $k ]]; then 
				if [ -f KPOINTS ]; then k="$(head -4 KPOINTS | tail -1 |rmSpace | cut -d ' ' -f 1-3)"; else return; fi; fi
			echo -n "Band number -> "; read band
			if [[ ! $band ]]; then
        if [ -f KPOINTS ]; then band=$(head -1 KPOINTS | cut -d ' ' -f 1); else return; fi; fi
			echo -n "Spin ( 1-up | 2-down ) -> "; read spin
			if [[ ! $spin ]]; then
        if [ -f KPOINTS ]; then spin=$(head -1 KPOINTS | cut -d ' ' -f 2); else return; fi; fi
      echo -n "Stencil for central difference ( 3 | 5 ) -> "; read st
      if [[ ! $st ]]; then
        if [ -f KPOINTS ]; then st=$(head -1 KPOINTS | cut -d ' ' -f 4); else return; fi; fi
			echo -n "Step size -> "; read step
			if [[ ! $step ]]; then
        if [ -f KPOINTS ]; then step=$(head -1 KPOINTS | cut -d ' ' -f 3); else return; fi; fi
      python3.7 /work/01293/hudamn/Edan/files/emc.py 'gen' $band $spin $step $st "$k"; echo ""
		elif [[ $1 == 2 ]]; then
			python3.7 /work/01293/hudamn/Edan/files/emc.py 'calc'
			highSymK
		elif [[ $1 == 3 ]]; then
			vi /work/01293/hudamn/Edan/files/emc.py; return
		else
			echo -e "\nUsage: emc <option> -> 1: KPOINTS generation; 2: Effective mass calulation; 3: edit EMC\n"; return
		fi
  }

  genK () {
		local c k kc kb kf step n 
    echo -ne "\nHole (h) or Electron (e) -> "; read c
    if [[ ! $c =~ ^[he]$ ]]; then echo -e "\nInvalid selection\n"; genK; fi
    bandEdges
    echo -n "k-point index -> "; read k
    if [[ $k =~ ^[0-9]+$ ]]; then
      if (( k <= $(cat kList | wc -l) )); then
        kc=($(head -$k kList | tail -1 | cut -d ' ' -f 1-3))
        kb=($(head -$((k-1)) kList | tail -1 | cut -d ' ' -f 1-3)); if [[ ! $kb ]]; then kb=0; fi
        kf=($(head -$((k+1)) kList | tail -1 | cut -d ' ' -f 1-3))
				if [ $(head -$((k+1)) kList | wc -l) == $(head -$k kList | wc -l) ]; then kf=0; fi
        echo -n "Step size (2pi/A) -> "; read step; 
        if [[ $step =~ ^[0-9]+\.*[0-9]*$ ]]; then 
          echo -n "Number of steps away from k-point -> "; read n
          if [[ ! $n =~ ^[0-9]+$ ]]; then echo -e "\nValue must be a positive integer"; genK; fi
        else
          echo -e "\nValue must be a positive integer or float"; genK
        fi
      else
        echo -e "\nk-point out of range"; genK
      fi
    else
      echo -e "\nValue must be a positive integer"; genK
    fi

		mkdir -p $c
    cp ../../{INCAR,POTCAR,CHGCAR,POSCAR,job} $c

    python3.7 - "${kb[*]}" "${kc[*]}" "${kf[*]}" $step $n $c <<- END
		import numpy as np
		from numpy import pi,dot,array
		from numpy.linalg import norm,inv
		from sys import argv
		from pymatgen.core.structure import Structure as st
		
		rec = st.from_file(argv[6]+'/POSCAR').lattice.reciprocal_lattice
		kb, kc, kf = [rec.get_cartesian_coords(i) if len(i) > 1 else "0"
									for i in [array([float(j) for j in k.split()]) if len(k) > 1 else "0" for k in argv[1:4]]]

		# define unit vectors
		if len(kb) > 1: ub = (kb-kc)/norm(kb-kc)
		if len(kf) > 1: uf = (kf-kc)/norm(kf-kc)

		k = []
		
		if len(kb) > 1:
		  for i in range(int(argv[5])): k.append(rec.get_fractional_coords(kc + ub*(i+1)*float(argv[4])))
			k.reverse()
		 
		k.append(rec.get_fractional_coords(kc))

		if len(kf) > 1:
		  for i in range(int(argv[5])): k.append(rec.get_fractional_coords(kc + uf*(i+1)*float(argv[4])))

		with open('kTest.txt','w') as f:
		  f.write("Step size = {0:0.3f} 2pi/A\n{1:d}\nrec\n".format(float(argv[4]),len(k)))
		  for i in k: f.write(" {0:11.8f} {1:11.8f} {2:11.8f}  0.01\n".format(i[0],i[1],i[2]))

		print("\n -> k-point grid generated!")

		END

 	  mv kTest.txt $c/KPOINTS; echo ""
  }

  effM () { # FIX COMPATABILITY WITH ISPIN=1

    # conversion factor -> (6.582e-16)^2[eVs]^2 * dk^2[1/A]^2 / d2E[eV] * {(3.00e18[A/s])^2 / 511[keV/c^2]} =~ 7.63
    
		local vbmI cbmI col vbm cbm s bn e k delK kb kf st step kpts

    kList ./

		vbmI=$(vbm i); cbmI=$((vbmI+1)); vbm=($(vbm eV)); cbm=($(vbm eC))

    echo -ne "\nSpin ( 1-up | 2-down ) -> "; read s; if [[ ! $s =~ ^[12]$ ]]; then s=1; fi; echo ''

    echo -n "Band index -> "; read bn # get band index
    if [[ $bn =~ ^[0-9]+$ ]]; then
      if (( $bn <= $(grep -m 1 NBANDS bands.xml | getNumber) )); then
        tail -n +8 EIGENVAL | grep " $bn " | rmSpace | cut -d ' ' -f 2,3 > eList; duplicateLines eList
      else echo -e "\nBand number out of range"; effM; fi
    else echo -e "\nBand value must be a positive integer"; effM; fi

    echo ""
    if [ $bn == $vbmI ]; then 
			e=${vbm[$((s-1))]}
		elif [ $bn == $cbmI ]; then 
			e=${cbm[$((s-1))]}
		elif (( bn < vbmI )); then
			e=$(cat eList | cut -d ' ' -f $s | sort | tail -1)
    else
      e=$(cat eList | cut -d ' ' -f $s | sort -r | tail -1)
    fi
    grep -m 1 -n -A 20 -B 20 $e eList | sed 's/[:-]/ /' | cut -d ' ' -f 1,$((s+1)) | sed "s/\($e\)/\1 <- \*/"
    echo ""

    # get k-point indices
    echo -n "k-point index -> "; read k
    if [[ $k =~ ^[0-9]+$ ]]; then
      if (( k <= $(cat kList | wc -l) )); then
        echo -n "Step size (points away from k) -> "; read delK
        if [[ $delK =~ ^[0-9]+$ ]]; then
          kb=$((k-delK)); kf=$((k+delK))
        else echo -e "\nDelta k must be a positive integer"; effM; fi
        echo -n "Stencil ( 3 | 5 ) -> "; read st
        if [ $st == 3 ] || [ $st == 5 ]; then step=$(((st-1)/2)); else echo -e "\nStencil must be 3 or 5"; return; fi
        if (( k + step*(kf-k) > $(cat kList | wc -l) )) || (( k - step*(kf-k) < 0 )); then 
          echo -e "\nk-points out of range"; effM
        else
          if [[ $step == 2 ]]; then
            kpts=($((2*kb-k)) $kb $k $kf $((2*kf-k)))
          else
            kpts=($kb $k $kf)
          fi
        fi
      else echo -e "\nk-point out of range"; effM; fi
    else echo -e "\nk-point index must be a positive integer"; effM; fi

		# convert kpoints to cartesian coordinates and calculate effective mass
		python3.7 - "${kpts[*]}" $s <<- END
		from numpy import array,abs
		from numpy.linalg import norm
		from sys import argv
		from pymatgen.core.structure import Structure as st

		rec = st.from_file('POSCAR').lattice.reciprocal_lattice

		indices = [int(i)-1 for i in argv[1].split(' ')]

		kf = [] # fractional coordinates
		with open('kList','r') as f:
      for line in enumerate(f.readlines()):
        if line[0] in indices:
          kf.append(array([float(i) for i in line[1].split('\n')[0].split()[0:3]]))

		k = [rec.get_cartesian_coords(i) for i in kf] # converted to cartesian coordinates
		kn = [i/max(abs(i)) if norm(i) != 0 else i for i in k] # normalize

		e = [] # energies in eV
		with open('eList','r') as f:
      for line in enumerate(f.readlines()):
        if line[0] in indices:
          e.append(float(line[1].split('\n')[0].split(' ')[int(argv[2])-1]))

		print("")
		print(e)

		if len(k) == 3:
      M = 7.63050245928016 / ((e[0]-2.0*e[1]+e[2])/norm(k[2]-k[1])**2)
		else:
      M = 7.63050245928016 / ((-e[0]+16.0*e[1]-30.0*e[2]+16.0*e[3]-e[4])/(12.0*norm(k[3]-k[2])**2))

		print("")
		for i, kpt in enumerate(zip(kf,kn)):
      print("k ( frac | cart ) = [%7.4f %7.4f %7.4f ] | [%7.4f %7.4f %7.4f ] ; e = %9.6f"
	      		% (kpt[0][0],kpt[0][1],kpt[0][2],kpt[1][0],kpt[1][1],kpt[1][2],e[i]))

		print("")
		index = int((len(k)+1)/2-1)
		print("backward = [ {0:0.3f} eV ; {1:0.3f} 2pi/A ]".format(abs(e[index]-e[index-1]),norm(k[index]-k[index-1])))
		print("forward  = [ {0:0.3f} eV ; {1:0.3f} 2pi/A ]".format(abs(e[index+1]-e[index]),norm(k[index+1]-k[index])))

		print("\nM_eff = %0.3f m_e\n" % M)

		END

  }

  calcBader () { # calculate bader charges
    if [ -e AECCAR0 ] && [ -e AECCAR2 ]; then 
      /work/01293/hudamn/Edan/files/extra/chgsum.pl AECCAR0 AECCAR2
    else
      echo -e "\nCore charges are missing!\n"
      return
    fi
    if [ -e CHGCAR_sum ]; then
      /work/01293/hudamn/Edan/files/extra/bader CHGCAR -ref CHGCAR_sum
			rm CHGCAR_sum
    else
      echo -e "\nMissing sum over core charges!\n"
      return
    fi
  }

  baderCharges () { # Usage: getBaderCharges ...

		local s n k j x i a c z 

		s=($(storePos s)); n=($(storePos n)); v=($(storePos v))

    if [ ! $1 ]; then
			echo -e "\nAverage net charges for (${s[*]}):\n"
			k=(${n[*]})
			j=1
			x=0
			for i in ${!s[*]}; do
			a=0
			while [ $j -le ${n[$i]} ]; do
  			c=$(grep " $j " ACF.dat | rmSpace | cut -d ' ' -f 5)
			  printf "%2s_%d = %6.3f e\n" ${s[$i]} $((j-x)) $(echo "${v[$i]} - $c" | bc)
  			a=$(echo $a + $c | bc)
  			((j++))
			done
			z=$(printf  "%0.3f e\n" $(echo "scale=16;${v[$i]} - $a / ${k[$i]}" | bc))
			echo -e "............... -> ${s[$i]}_avg = $z\n"
			n[$i+1]=$((n[$i+1] + n[$i]))
			x=$((j-1))
			done
    else
      a=()
      a=$*
      for i in ${a[*]}; do
        s=()
        n=$(echo $i | cut -d '_' -f 1)
        if [ $(echo $i | grep _) ]; then s=($(echo $i | cut -d '_' -f 2 | sed 's/,/ /g')); fi
        c=($(grep " $n " ACF.dat | sed 's/  */ /g' | cut -d ' ' -f 3,4,5,6))
        if [ ${s[0]} ]; then
          x=($(head -3 POSCAR | tail -1))
          c[0]=$(echo "${c[0]} + ${x[0]} * ${s[0]}" | bc)
          c[1]=$(echo "${c[1]} + ${x[1]} * ${s[0]}" | bc)
          c[2]=$(echo "${c[2]} + ${x[2]} * ${s[0]}" | bc)
        fi
        if [ ${s[1]} ]; then
          x=($(head -4 POSCAR | tail -1))
          c[0]=$(echo "${c[0]} + ${x[0]} * ${s[1]}" | bc)
          c[1]=$(echo "${c[1]} + ${x[1]} * ${s[1]}" | bc)
          c[2]=$(echo "${c[2]} + ${x[2]} * ${s[1]}" | bc)
        fi
        if [ ${s[2]} ]; then
          x=($(head -5 POSCAR | tail -1))
          c[0]=$(echo "${c[0]} + ${x[0]} * ${s[2]}" | bc)
          c[1]=$(echo "${c[1]} + ${x[1]} * ${s[2]}" | bc)
          c[2]=$(echo "${c[2]} + ${x[2]} * ${s[2]}" | bc)
        fi
        printf "%0.3f %0.3f %0.3f %0.3f\n" ${c[3]} ${c[0]} ${c[1]} ${c[2]}
      done
    fi
  }

# get direct gaps
  getDirectGap () {
		local vbm up dn
    vbm=$(tail -n +8 EIGENVAL | rmSpace | grep -m 1 -B 1 '0\.0* 0\.0*' | head -1 | rmSpace | cut -d ' ' -f 1)
		tail -n +8 EIGENVAL | grep " $vbm " | rmSpace | cut -d ' ' -f 2,3 > vbm
		tail -n +8 EIGENVAL | grep " $((vbm+1)) " | rmSpace | cut -d ' ' -f 2,3 > cbm
		paste vbm cbm | awk '{printf "%0.3f %0.3f\n", $3-$1, $4-$2}' > directGap; rm vbm cbm
	  up=$(cat directGap | cut -d ' ' -f 1 | sort -nr	| tail -1)
    dn=$(cat directGap | cut -d ' ' -f 2 | sort -nr | tail -1)
		rm directGap
		printf "\nSpin up   -> %0.3f eV" $up
		printf "\nSpin down -> %0.3f eV\n" $dn
		echo ""
  }

# generate DOS plot
  parseD () {

		local path vbm num fermi s n v OFS j m k maxO i ions ranges range rMin rMax \
					a cS cP cD cSu cSd cPu cPd cDu cDd l col xS xP xD xSu xSd xPu xPd xDu xDd \
					p pos1 pos2 species c1 o x gap

		if [ -d PDOS ]; then rm -fr PDOS; fi; mkdir PDOS/

		if [ $1 ]; then
			path=$1
		else
    	path=output/dos/$(grep DOS status | tail -1 | cut -d ' ' -f 6-10 | sed 's/ //g')
		fi

		vbm=$(math floor $(math min $(vbm eV)))
		num=$(getTag NEDOS)

		echo -e "\n$(grep '\.... ' $path/DOSCAR | rmSpace | head -$num | grep "^$vbm\.... ") \n"
    echo -n "Enter Fermi level -> "; read fermi

		s=($(storePos s)); n=($(storePos n))

    grep '\.... ' $path/DOSCAR | rmSpace > dosData

    head -$num dosData | tail -$num > PDOS/total
    if [[ $(getTag ISPIN) == 2 ]]; then
      awk '{print $1,$2*1,$3*-1,$4,$5}' OFS=" " PDOS/total | sed 's/e/E/g' > PDOS/temp; mv PDOS/temp PDOS/total 
    fi

		l=2
		for j in ${!s[*]}; do
			for k in $(range ${n[$j]}); do 
				m=$((num * l)); ((l++))
        head -$m dosData | tail -$num > PDOS/${s[$j]}$((k+1))
      done
    done; rm dosData

  # sum over requested ions
    maxO=$(tail -1 $path/DOSCAR | grep -o '[0-9]*\.[0-9]*' | wc -l)
		for j in ${!s[*]}; do

		# get list of sites for current element
      echo -n "Enter ${s[$j]} ions to sum over (1-${n[$j]}) -> "; read ions; echo $ions > list
      ranges=($(grep -o '[0-9][0-9]*-[0-9][0-9]*' list))
      for i in ${ranges[*]}; do
        range=(); rMin=$(echo $i | cut -d '-' -f 1); rMax=$(echo $i | cut -d '-' -f 2)
        while (( rMin <= rMax )); do
          range=(${range[*]} $rMin); ((rMin++))
        done
        sed -i "s/$i/${range[*]}/" list
      done

    # collect ionic contributions for requested list
      a=()
      if [ $(getTag ISPIN) == 1 ]; then
        cS=('$2 '); cP=('$3 '); cD=('$4 ')
      else
        cSu=('$2 '); cSd=('$3 '); cPu=('$4 '); cPd=('$5 '); cDu=('$6 '); cDd=('$7 ')
      fi
      l=1
      for k in $(grep '' list); do
        a=(${a[*]} "PDOS/${s[$j]}$k")
        col=$(echo "$maxO * $l" | bc)
        if [ $(getTag ISPIN) == 1 ]; then
          xS=$((2 + col)); xP=$((3 + col)); xD=$((4 + col))
          cS=(${cS[*]} '+ $'"$xS"''); cP=(${cD[*]} '+ $'"$xP"''); cD=(${cP[*]} '+ $'"$xD"'')
        else
          xSu=$((2 + col)); xSd=$((3 + col)); xPu=$((4 + col)); xPd=$((5 + col)); xDu=$((6 + col)); xDd=$((7 + col))
          cSu=(${cSu[*]} '+ $'"$xSu"''); cSd=(${cSd[*]} '+ $'"$xSd"'');
          cPu=(${cPu[*]} '+ $'"$xPu"''); cPd=(${cPd[*]} '+ $'"$xPd"'');
          cDu=(${cDu[*]} '+ $'"$xDu"''); cDd=(${cDd[*]} '+ $'"$xDd"'');
        fi
        ((l++))
      done
      if [ $(getTag ISPIN) == 1 ]; then
        c=("${cS[*]}" "${cP[*]}" "${cD[*]}")
      else
        c=("${cSu[*]}" "${cSd[*]}" "${cPu[*]}" "${cPd[*]}" "${cDu[*]}" "${cDd[*]}")
      fi
      pos1=("%0.5f"); pos2=()
			for i in $(range $((maxO - 1))); do
        pos1=(${pos1[*]} " %0.5f"); pos2=(${pos2[*]} "${c[$i]}")
      done
      col=$(echo ${pos2[*]} | sed -e 's/ + /+/g' -e 's/ /,/g')
      paste $(echo ${a[*]}) | awk '{ printf "'"${pos1[*]}"'\n", $1,'"$col"' }' > PDOS/${s[$j]}
      if [ $(getTag ISPIN) == 2 ]; then
        awk '{print $1,$2*1,$3*-1,$4*1,$5*-1,$6*1,$7*-1}' OFS=" " PDOS/${s[$j]} > PDOS/temp
        mv PDOS/temp PDOS/${s[$j]}
      fi
    done
    rm list

  # combine results for plotting
			vbm=$(vbm i); gap=$(getGap $vbm $((vbm + 1)) $path 1)
      if [ $(getTag ISPIN) == 1 ]; then
        echo -n "" "Total" > PDOS/DOS_$gap.dos
      else
        echo -n "" "Total_u Total_d" > PDOS/DOS_$gap.dos
      fi
      species=()
      if [ $(getTag ISPIN) == 1 ]; then
        o=(s p d); c1=("%0.5f" "%0.5f"); x=5
      else
        o=(s_u s_d p_u p_d d_u d_d); c1=("%0.5f" "%0.5f" "%0.5f"); x=7
      fi
      for i in ${!s[*]}; do
        species=(${species[*]} "PDOS/${s[$i]}")
				for j in $(range $((maxO - 1))); do
          if [[ ! ${s[$i]}_${o[$j]} =~ O_d_[ud] ]]; then
            echo -n " ${s[$i]}_${o[$j]}" >> PDOS/DOS_$gap.dos
            c1=(${c1[*]} "%0.5f")
            echo -n '$' >> col; echo -n "$x " >> col
          fi
          ((x++))
        done
        ((x++))
      done
      if [ $(getTag ISPIN) == 2 ]; then echo '$3' $(grep '' col) > col; fi
      col=$(grep '' col | sed -e 's/ /,/g' -e 's/,$//'); rm col
      echo "" >> PDOS/DOS_$gap.dos
      perl -lane 'BEGIN{$"=" "}$F[0]=$F[0]-'"$fermi"';print "@F"' PDOS/total > PDOS/totalFermi
      paste PDOS/totalFermi ${species[*]} | awk '{ printf "'"${c1[*]}"'\n", $1,$2,'"$col"'}' >> PDOS/DOS_$gap.dos
      echo ""
  }      

  intDOS () { # integrate total DOS

		local min max l u lNum uNum Iu Id a b I

    min=$(echo "$(grep '' PDOS/totalFermi | head -1 | cut -d ' ' -f 1) / 1" | bc)
    max=$(echo "$(grep '' PDOS/totalFermi | tail -1 | cut -d ' ' -f 1) / 1" | bc)
    echo -e "\nRange: $min eV - $max eV"
    echo -ne "\nEnter lower bound -> "
      read l
    echo -ne "Enter upper bound -> "
      read u
    lNum=$(grep -n "^$l.[0-9]*" PDOS/totalFermi | tail -1 | cut -d ':' -f 1)
    uNum=$(grep -n "^$u.[0-9]*" PDOS/totalFermi | tail -1 | cut -d ':' -f 1)
    echo $lNum $uNum
    Iu=0
    Id=0
    while [ $lNum -lt $uNum ]; do
      a=($(grep -n '' PDOS/totalFermi | grep "^$lNum:" | cut -d ':' -f 2 | cut -d ' ' -f 1-3))
      b=($(grep -n '' PDOS/totalFermi | grep "^$((lNum+1)):" | cut -d ':' -f 2 | cut -d ' ' -f 1-3))
      Iu=$(echo "$Iu + $(echo "(${b[0]} - ${a[0]}) * (${a[1]} + ${b[1]}) * 0.5" | bc)" | bc)
      Id=$(echo "$Id + $(echo "(${b[0]} - ${a[0]}) * (${a[2]} + ${b[2]}) * -0.5" | bc)" | bc)
      ((lNum++))
    done
    I=$(echo "$Iu + $Id" | bc)
    printf "\nTotal -> %0.3f \n" $I
    printf "Spin up -> %0.3f\n" $Iu
    printf "Spin down -> %0.3f\n\n" $Id
  }

# calculate percent error to experimental
  perErr () {
		local err
    err=$(echo "($1 / $2 - 1) * 100" | bc -l | xargs printf %0.1f)
    if (( $(echo "$err < 0" | bc -l) )); then
      echo "$err%"
    else
      echo "+$err%"
    fi
  }

  getLat () { # get lattice parameters (any argument to print)
    local i j l a1 a2 a3; l=3; for i in a1 a2 a3; do for j in 0 1 2; do
      eval "$i[$j]=$(head -$l POSCAR | tail -1 | rmSpace | cut -d ' ' -f $((j+1)))"
    done; ((l++)); done
		mags=($(
				python3.7 - "${a1[*]}" "${a2[*]}" "${a3[*]}" <<- END
         
				from sys import argv
				import numpy as np
				 
				for i in range(3): print(np.linalg.norm([float(j) for j in argv[i+1].split()]))
		END
		))
    if [[ $1 == disp ]]; then 
      printf "%s\n" ${mags[*]}
    elif [[ $1 == pass ]]; then
     	echo "${a1[*]}" "${a2[*]}" "${a3[*]}"
    fi
  }

# get current POSCAR parameters
  storePos () {

		local i s n v elec ion

		s=($(head -6 POSCAR | tail -1))
    n=($(head -7 POSCAR | tail -1))

		if [ $1 ]; then case $1 in
			s) 	echo "${s[*]}"; return ;;
			n)	echo "${n[*]}"; return ;;
			*)
		   	v=()
			  elec=0
		    ion=0
			  for i in ${!s[*]}; do
					if [[ $(grep PAW_PBE POTCAR) ]]; then
	  	    	v=(${v[*]} $(echo "$(grep -A 1 "^ PAW_PBE ${s[$i]}.*" POTCAR | tail -1 | getNumber) / 1" | bc))
  		  	else
  		  	  v=(${v[*]} $(echo "$(grep -A 1 "^ PAW ${s[$i]}.*" POTCAR | tail -1 | getNumber) / 1" | bc))
			    fi
  	  	  elec=$(echo "$elec + (${n[$i]} * ${v[$i]})" | bc)
			    ion=$(echo "$ion + ${n[$i]}" | bc)
		   	done ;;
			esac
		fi
		case $1 in 
			v) echo "${v[*]}" ;;
			e) echo $elec ;;
			i) echo $ion ;;
		esac
  }

# get ionic forces
  forces () {

		if [ ! -f OUTCAR ]; then echo -e "\n -> No OUTCAR found"!"\n"; return; fi
		
		local n ax

    n=$(grep NIONS OUTCAR | rev | cut -d ' ' -f 1 | rev)
		if [[ $1 ]]; then ax=$1; else ax=$(index $(getLat disp | sort -n | tail -1) "$(getLat disp)"); fi
		sed -n '/TOTAL-FORCE/,/total drift/p' OUTCAR | tail -$((n + 4)) | clip b 2 > temp1
		grep -o ' [TF] .*' POSCAR > temp2
		paste temp1 temp2 | rmSpace | sort -k$((ax+1)) -n | cut -d ' ' -f 4- > temp3 # sorted by longest lattice parameter

		python3.7 - $(getTag EDIFFG | cut -d '-' -f 2) <<- END

			from sys import argv
			from colorama import Fore

			cutoff = float(argv[1])				

			with open('temp3','r') as f:
			  for line in f.readlines():
			    args = line.split()
			    if 'T' in args or len(args) == 3:
			      args.append('--->')
			      for n in range(3):
			        if args[n+3] == 'T' or len(args) - n == 4:
			          if abs(float(args[n])) <= cutoff:
			            args.append(eval('Fore.GREEN + "1"'))
			          else:
			            args.append(eval('Fore.RED + "0"'))
			      args.append(eval('Fore.BLACK'))

			    vars = tuple([float(i) for i in args[:3]] + args[3:])
			    if len(args) == 8:
			      print('%10.6f %10.6f %10.6f %s %s %s %s %s' % vars)
			    elif len(args) == 6:
			      print('%10.6f %10.6f %10.6f   <%s %s %s>' % vars) 
			    else:
			      print('%10.6f %10.6f %10.6f   <%s %s %s> %s %s %s %s %s' % vars)

		END

		rm temp[123]

		# sed -n '/TOTAL-FORCE/,/total drift/p' OUTCAR | tail -$((n + 4)) # print Forces as they appear in OUTCAR
  }

# get nearest neighbor table
  nearest () {
		local n
    n=$(grep NIONS OUTCAR | rev | cut -d ' ' -f 1 | rev)
    sed -n "/nearest neighbor/,/ $n  /p" OUTCAR | sed '/^$/d'
  }

  enbTag () { # enable INCAR tag
		local i
    for i in $*; do sed -i "/#$i /s/#//" INCAR; done
  }

  disTag () { # disable INCAR tag
		local i
    for i in $*; do sed -i "/^$i /s/^ */#/" INCAR; done
  }

  setTag () { # update an INCAR tag
		local tag tags vals row value path
    if [[ $1 ]]; then
			tags=($1); vals=($2); path=$3; set ${path:=./}
			if [[ ${#tags[*]} != ${#vals[*]} ]]; then vals=${vals[*]}; fi
			for tag in ${!tags[*]}; do sed -i "/^#*${tags[$tag]} /s/=.*/= ${vals[$tag]/,/ }/" $path/INCAR; done
    else
      echo ""; grep -n = INCAR | cut -d '=' -f 1 | sed 's/#//'; echo ""
      echo -n "Which tag? (enter numeric value) -> "; read row
      echo -n "Enter new value -> "; read value
      tag=$(head -$row INCAR | tail -1 | cut -d '=' -f 1)
      setTag $tag $value
      echo "" 
    fi
  }

  getTag () { # get INCAR tag value
		local file
		if [ $2 ]; then file=$2; else file=INCAR; fi
    echo -n $(cat $file | rmSpace | grep "^#*$1 " | cut -d ' ' -f 3)
  }

  showTag () { # write INCAR tag to file
    if [ $1 == ISMEAR ] && [ $(getTag $1) != -5 ]; then 
      echo -n "$1 = $(getTag $1) ($(getTag SIGMA))"; else echo -n "$1 = $(getTag $1)"; fi
    if [[ ! $2 ]]; then echo ""; else echo -n " $2 "; fi
  }
  
  defEn () { # get default ENCUT from POTCAR
    grep ENMAX POTCAR | cut -d ' ' -f 8 | cut -c 1-7 | sort -nr | head -1 | xargs printf '%0.f'
  }

  kPoints () { # set KPOINTS
    if [ ! "$*" ]; then 
      echo "Usage: kPoints <k1> <k2> <k3> -> k1 only to calculate k2 & k3 according to lattice"; return
    elif [ ! $2 ] || [ ! $3 ]; then

			local a1 a2 a3 k
      
			a1=($(getLat pass | cut -d ' ' -f 1-3))
      a2=($(getLat pass | cut -d ' ' -f 4-6))
      a3=($(getLat pass | cut -d ' ' -f 7-9))

			if [[ $2 == even ]]; then odd=False; else odd=True; fi

      k=($(

				python3.7 - $1 "${a1[*]}" "${a2[*]}" "${a3[*]}" $odd <<- END

				from sys import argv
				import numpy as np

				odd = argv[-1]

				k1 = int(argv[1])
				k1 = k1 + 1 if odd == 'True' and k1 % 2 == 0 else k1

				# define real lattice
				a = [np.array([float(j) for j in i.split()]) for i in argv[2:5]]
				realVecs = [np.linalg.norm(r) for r in a]

				# define reciprocal lattice
				b = [(np.dot(a[0], np.cross(a[1], a[2])))**-1 * np.cross(i, j) for i, j in [a[1:3], [a[2], a[0]], a[0:2]]]
				recVecs = [np.linalg.norm(r) for r in b]

				# define ratios with respect to shortest vector
				longIndex = recVecs.index(max(recVecs))
				r21 = recVecs[(longIndex + 1) % len(recVecs)] / recVecs[longIndex]
				r31 = recVecs[(longIndex + 2) % len(recVecs)] / recVecs[longIndex]

				k2 = int(k1 * r21)
				k3 = int(k1 * r31)

				k2, k3 = [i + 1 if odd == 'True' and i % 2 == 0 else i for i in [k2, k3]]

				k = []
				for i in range(3):
			  	if i == longIndex: 
            k.append(k1)
			  	elif i == (longIndex + 1) % len(recVecs):
            k.append(k2)
			  	else:
            k.append(k3)
			
				print(k[0], k[1], k[2])

			END
			
			))

    else
      k=($*)
    fi
		if [[ $(inArray 0 "${k[*]}") ]]; then 
			echo -e "\n -> Null index detected. Please use larger k value.\n"
		else 
    	sed -i "4s/.*/${k[0]}  ${k[1]}  ${k[2]}/" KPOINTS
		fi
  }
  
  getKps () { # get KPOINTS
    echo "$(head -4 KPOINTS | tail -1 | rmSpace | cut -d ' ' -f 1-3)"
  }

  setKps () {
		local k
    echo -n "Kpoints (enter kx only to extrapolate) -> "; read k
    if [[ ! $k =~ ^[0-9]+$ ]]; then k=1; fi; kPoints $k
  }

  getTime () { # get elapsed time of last VASP run

		local raw t_days days t_hr hr r_min min t_sec sec
		
		raw=$(grep Elapsed OUTCAR | rev | cut -d ' ' -f 1 | rev)
    t_days=$(echo "$raw / 86400" | bc -l)
    days=$(echo "$t_days / 1" | bc)
    t_hr=$(echo "($t_days - $days) * 24" | bc)
    hr=$(echo "$t_hr / 1" | bc)
    t_min=$(echo "($t_hr - $hr) * 60" | bc)
    min=$(echo "$t_min / 1" | bc)
    t_sec=$(echo "($t_min - $min) * 60" | bc)
    sec=$(printf %0.f "$t_sec")
    if [ "$(echo "$sec < 10" | bc)" == 1 ]; then sec="0$sec"; fi
    if [ "$(echo "$min < 10" | bc)" == 1 ]; then min="0$min"; fi
    if [ "$(echo "$hr < 10" | bc)" == 1 ]; then hr="0$hr"; fi
    echo "$(if (( days != 0 )); then echo -n "($days) "; fi)$hr:$min:$sec" 
  }

  getVolume () { # get current cell volume

		local vol

		if [ -f OUTCAR ]; then
   	  vol=$(grep volume OUTCAR | tail -1 | getNumber)
		else
			vol=$(math triProd $(getLat pass) | xargs printf %0.2f)
		fi

    printf "VOLUME = %0.2f" $vol

  }

  getEnergy () { # display energy (eV) with calculation parameters
    
		local algo cycl smear volume energy occ ediff
		
		occ=$(occCheck 1)
    algo=$(grep -B 1 ' F= ' OSZICAR | tail -2 | head -1 | cut -c 1-3)
    cycl=$(grep -B 1 ' F= ' OSZICAR | tail -2 | head -1 | rmSpace | cut -d ' ' -f 2)
    smear=$(getTag ISMEAR)
    volume=$(getVolume | getNumber)
    energy=$(grep "free  energy" OUTCAR | tail -1 | getNumber | xargs printf %0.5f)
		ediff=$(grep -B 1 E0 OSZICAR | tail -2 | head -1 | rmSpace | cut -d ' ' -f 4 | grep -o E.*)
    echo -ne "E0 = $energy; 1$ediff; ($(getKps)); $(getTag ENCUT); $(getTag NBANDS); $cycl ($algo)"
    echo -n "; $smear$(if [ $smear != -5 ]; then echo -n " ($(getTag SIGMA | xargs printf %0.3f))"; fi)"$occ"; $(getTag PREC)"
		echo -n "$(if [[ $1 ]]; then echo "; R$4$5 $2($3): $1 ($(getTag EDIFFG)); $volume"; fi)"
		echo "; $(getTime)"
  }

  realSpace () { # write real space matrix
    echo ""; local a1 a2 a3
    a1=($(getLat pass | cut -d ' ' -f 1-3))
    a2=($(getLat pass | cut -d ' ' -f 4-6))
    a3=($(getLat pass | cut -d ' ' -f 7-9))
    printf "( %0.3f  %0.3f  %0.3f )\n\n" ${a1[0]} ${a1[1]} ${a1[2]}
    printf "( %0.3f  %0.3f  %0.3f )\n\n" ${a2[0]} ${a2[1]} ${a2[2]}
    printf "( %0.3f  %0.3f  %0.3f ) -> $(getVolume)\n\n" ${a3[0]} ${a3[1]} ${a3[2]}
  }

  abs () { # Usage: abs <value 1> <value 2>
    if [ "$(echo "$1 - $2 >= 0" | bc)" == 1 ]; then
      echo "($1 - $2) * 1" | bc
    else
      echo "($1 - $2) * -1" | bc
    fi
  }

  getGap () { # Usage: getGap <vbm> <cbm> <path> -> default path = current dir
    local path vbMax cbMin
    if [ $3 ]; then path=$3; else path=.; fi
    vbMax=$(sed '1,7d' $path/EIGENVAL | grep " $1 " | rmSpace | cut -d ' ' -f 3 | sort -n | tail -1)
    cbMin=$(sed '1,7d' $path/EIGENVAL | grep " $2 " | rmSpace | cut -d ' ' -f 3 | sort -rn | tail -1)
    printf %0.3f "$(echo "$cbMin - $vbMax" | bc)"
    if [ ! $4 ]; then echo ""; fi
  }

# modify POSCAR #####################################################################################################
  posMod () {

		local dir def vac s n s1 i el loc defect x k l ind c

    getElement() {
      s1=()
      for i in ${!s[*]}; do s1+=("$i-${s[$i]}"); done
      echo -n "Select element to modify ( $(echo "${s1[*]}" | sed 's/ / | /g') ) -> "; read el
			if [ ! $(inArray $el "${!s[*]}") ]; then echo 'Element does not exist in system!'; getElement; fi
    }

    getLocation() {
      echo -n "Select location (1-${n[$el]}) -> "; read -a loc
      for i in ${loc[*]}; do
				if [ ! $(inArray $i "$(range $((${n[$el]}+1)) 1)") ]; then echo 'Not a valid location!'; getLocation; fi
      done
    }

    getReplace() {
      echo -n "Choose dopent element (leave blank for vacancy) -> "; read defect
      if [[ $defect ]] && [[ ! $(grep "^ PAW_PBE $defect[_ ]" $dir) ]]; then
        echo 'Not a valid defect!'
        getReplace
      fi
    }

    runMod() {

      s=($(storePos s)); n=($(storePos n))
      getElement; getLocation; getReplace

      for k in ${loc[*]}; do
        l=$((k + 8 - x)); for i in $(range $el); do l=$((l + ${n[$i]})); done # determine line of selected defect
        if [ ! $defect ]; then
					sed -i -e "7s/[0-9][0-9]*/$((${n[$el]} - 1))/$((el + 1))" POSCAR # -e "$l"d POSCAR
				else
					if [ ! $(inArray $defect "${s[*]}") ]; then
						sed -i -e "6s/.*/&   $defect/" -e "7s/.*/&    1/" POSCAR
					else
						ind=$(index $defect "${s[*]}")
						sed -i "7s/[0-9][0-9]*/$((${n[$ind]} + 1))/$((ind + 1))" POSCAR
					fi
				fi
			done
						
				head -$l POSCAR | tail -1 >> POSCAR # move coordinate to end of file
				sed -i "${l}d" POSCAR # delete old coordinate
			return
			sed -i "6s/\(.*\)/$(tail -n +6 POSCAR | head -1 | xargs printf %4s%4s%4s%4s)/" POSCAR
			sed -i "7s/\(.*\)/$(tail -n +7 POSCAR | head -1 | xargs printf %4s%4s%4s%4s)/" POSCAR
    }

  # execute modifications
		if [ ! -d tempPos ]; then cp POSCAR tempPos; fi
		sed -i -e '1s/  */ /g' -e '1s/ $//' POSCAR # reformat POSCAR title
		blank=$(grep -n '^[\t ]*$' POSCAR | head -1 | cut -d ':' -f 1); if [[ $blank ]]; then sed -i "$blank,\$d" POSCAR; fi
		dir=/work/01293/hudamn/Edan/PAW_PBE

    echo ""; runMod; echo ""; head -7 POSCAR; echo ""

  # prompt user for subsequent modification
    c=1
    while [ $c != 0 ]; do
      echo -n "Enter 1 for additional modification; 0 to exit -> "; read c
      if [ $c != 1 ] && [ $c != 0 ]; then echo 'Not a valid selection!'; fi
      if [ $c == 1 ]; then
        runMod
        echo ""
        head -7 POSCAR
        echo ""
      else
				getFiles
				getJob IN
      fi
    done
  }
#####################################################################################################################
