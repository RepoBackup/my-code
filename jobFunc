#!/bin/bash

source /work/01293/hudamn/Edan/genFunc

FC () { # font color
	if [ $3 ]; then echo $(tput setaf $1)$2; else echo -n $(tput setaf $1)$2; fi; tput sgr0
}

BC () { # background color
  if [ $3 ]; then echo $(tput setab $1)$2; else echo -n $(tput setaf $1)$2; fi; tput sgr0
}

getFiles () { # copy work files
	cp INCAR oldINCAR 2>/dev/null
	cp /work/01293/hudamn/Edan/files/general/* ./
	if [ -f oldINCAR ]; then setTag 'NBANDS NPAR' "$(getTag NBANDS oldINCAR) $(getTag NPAR oldINCAR)"; rm oldINCAR; fi 
	if [ -f POSCAR ]; then
		local func
    echo -ne "\nFunctional ( 0: LDA | 1: GGA | $(FC 2 2): PBE ) -> "; read func
		SetUp $func
	else
		echo -e "\nNo POSCAR found. Get POSCAR and run SetUp!\n"
	fi
	
}

editJob () { # edit job template
  if [ $1 ] && [ $(inArray $1 "IN R C SP D B V") ]; then
		vi /work/01293/hudamn/Edan/files/jobs/job$1
  else
		local x
		echo -ne "\nSelect job type < IN | R | C | SP | D | B > -> "; read x; echo ""; editJob $x
  fi
}

editINCAR () { # edit INCAR template
	vi /work/01293/hudamn/Edan/files/general/INCAR
}

name () { # set system name
	local name x term; term=0
	if [ $1 ]; then x=$1; fi; set ${x:=$(grep "\-J" job | cut -d '_' -f 2)}
  echo -ne "\nEnter system name -> "; read name
  if [ ! $name ]; then
    if [ -f prevJob ]; then
      name=$(grep "^#SBATCH -J" prevJob | cut -d ' ' -f 3 | cut -d '_' -f 1)
    else
      echo -e "\nNo previous job found"; name; term=1
    fi
  fi
	if (( term == 0 )); then
	  sed -i "s/^#SBATCH -J.*/#SBATCH -J "$name"_"$x"/" job
	  sed -i "1s/.*/$name/" POSCAR
	fi
}

queue () { # set queue
	local q term; term=0
	if [ $1 ]; then
		q=$1
	else
	  echo -n "Select queue ( 1-normal | 2-development ) -> "; read q
	  if [[ ! $q ]]; then
  	  if [ -f prevJob ]; then
    	  q=$(grep "^#SBATCH -p" prevJob | cut -d ' ' -f 3)
				if [[ $q == normal ]]; then q=1; else q=2; fi
	    else
  	    echo -e "\nNo previous job found\n"; queue; term=1
	    fi
		fi
	fi
	if (( q == 1 )); then q=normal; else q=development; fi
	if (( term == 0 )); then sed -i "s/^#SBATCH -p .*/#SBATCH -p $q/" job; fi
}

tLim () { # set time limit
	local tUnit t job term; term=0
  if [ $1 ]; then tUnit=$1; else echo -n "Enter time unit ( 1-hours | 2-minutes ) -> "; read tUnit; fi
	if [ $3 ]; then file=$3; else file=job; fi
  if [ ! $tUnit ]; then
    if [ -f prevJob ]; then
      t=$(grep "^#SBATCH -t" prevJob | cut -d ' ' -f 3)
      sed -i "s/^#SBATCH -t .*/#SBATCH -t $t/" $file
    else
      echo -e "\nNo previous job found\n"; tLim; term=1
    fi
  else
    timeLimit() {
			local t
      if [ $1 ]; then t=$1; else echo -n "Enter time limit -> "; read t; fi
      if [ ! $t ] || [[ ! $t =~ ^[0-9]+$ ]]; then
        echo -e "\nInvalid time limit\n"; timeLimit $1
      elif [ $tUnit == 1 ]; then
        sed -i "s/^#SBATCH -t .*/#SBATCH -t $(echo $t | xargs printf '%s:00:00')/" $file
      else
        if (( t < 10 )); then t="0$t"; fi
        sed -i "s/^#SBATCH -t .*/#SBATCH -t $(echo $t | xargs printf '00:%s:00')/" $file
      fi
    }
    if (( term == 0 )); then timeLimit $2; fi
  fi
}

cores() { # set number of cores
	local cores term; term=0
  echo -ne "Enter number of cores -> "; read cores
  if [ ! $cores ]; then
    if [ -f prevJob ]; then
      cores=$(grep "^#SBATCH -n" prevJob | cut -d ' ' -f 3)
    else
      echo -e "\nNo previous job found\n"; cores; term=1
    fi
  fi
  if (( term == 0 )); then sed -i "s/^\(\#SBATCH -n\).*/\1 $cores/1" job; fi
}

nodes() { # set number of nodes
	local nodes t; term=0
  echo -ne "Enter number of nodes -> "; read nodes
  if [ ! $nodes ]; then
    if [ -f prevJob ]; then
      nodes=$(grep "^#SBATCH -N" prevJob | cut -d ' ' -f 3)
    else
      echo -e "\nNo previous job found\n"; nodes; term=1
    fi
  fi
  if (( term == 0 )); then sed -i "s/^\(\#SBATCH -N\).*/\1 $nodes/" job; fi
}

getJob () { # get job template

	cp INCAR oldINCAR 2>/dev/null

	local x nElect

  if [ $1 ] && [ $(inArray $1 "IN R C SP D B") ]; then x=$1; else x=''; fi
	if [ -f job ]; then cp job prevJob; fi
	cat /work/01293/hudamn/Edan/files/jobs/job$1 > job # write job file
	echo -e "\n$(FC 2 '### Leave blank for previous job parameters ###')"
	case $x in
		IN)
#				local encut k1 
#				echo -en "\nENCUT ($(FC 2 ENMAX)) -> "; read encut
#				if [ ! $encut ]; then encut=$(defEn); echo "Using default ENCUT of $(defEn) eV"; fi
#				echo -n "k-point ($(FC 2 1)) -> "; read k1; set ${k1:=1}
#				setTag ENCUT $encut; sed -i "s/\(kPoints\).*/\1 $k1/" job ;;
				setTag ENCUT 600; sed -i "s/\(kPoints\).*/\1 1/" job ;;
		C)
				local tType cycles crit ismear sig step defEn cent val k1 nBands
				echo -en "\nConvergence test ( $(FC 2 K): KPOINTS) | E: ENCUT | N: NBANDS | S: SIGMA ) -> "; read tType; set ${tType:=K}
				echo -n "Convergence criteria ($(FC 2 0.001)) -> "; read crit; set ${crit:=0.001}
				if [[ ! $tType == K ]]; then echo -n "k-point ($(FC 2 1)) -> "; read k1; set ${k1:=1}; fi
				case $tType in
					K)	
						k1=$(grep E0 status | tail -1 | cut -d ';' -f 3 | getNumber | sort -r | head -1); kPoints $((k1+2))
						cycles=10 ;;
					E)
						defEn=$(defEn); cent=$(echo "$defEn / 100 * 100" | bc)
						if [[ $cent == $(echo "$defEn / 1" | bc) ]]; then 
							val=$cent
       			elif [[ $(echo "($defEn - $cent) <= 25" | bc) == 1 ]]; then 
							val=$((cent + 25))
       			elif [[ $(echo "($defEn - $cent) > 25 && ($defEn - $cent) <= 50" | bc) == 1 ]]; then 
							val=$((cent + 50))
       			elif [[ $(echo "($defEn - $cent) > 50 && ($defEn - $cent) <= 75" | bc) == 1 ]]; then 
							val=$((cent + 75))
       			else 
							val=$((cent + 100))
						fi
						setTag ENCUT $val; kPoints $k1; sed -i "s/^val=.*/val=$val/" job ;;
					N)
       			nElect=$(storePos e); if (( nElect % 2 != 0 )); then ((nElect++)); fi
						step=$(getTag NPAR); nBands=$((nElect / 2 + step))
						sed -i -e "s/^nBands=.*/nBands=$nBands/" -e "s/^step=.*/step=$step/" job
       			setTag 'NBANDS ICHARG' "$nBands 12" ;;
					S)
						kPoints $k1
						echo -n "Smearing type ( -1: fermi | $(FC 2 0): gauss | >0: MP ) -> "; read ismear; set ${ismear:=0}
           	echo -n "Initial SIGMA ($(FC 2 INCAR))-> "; read sig; set ${sig:=$(getTag SIGMA)}
           	echo -n "Step size ($(FC 2 0)) -> "; read step; set ${step:=0}
						if [[ $(echo "$step != 0" | bc) == 1 ]]; then
							cycles=$(abs $(echo "$sig / $step - 1" | bc) 0)
						else
							cycles=1
						fi
					  sed -i -e "s/^\(ismear=\).*/\1$ismear/" -e "s/^\(sig=\).*/\1$sig/" -e "s/^\(step=\).*/\1$step/" job	
				esac
				if [[ ! $tType =~ [SK] ]]; then echo -n "Number of iterations ($(FC 2 1))-> "; read cycles; set ${cycles:=1}; fi
				sed -i -e "s/\(tType=\).*/\1$tType/" -e "s/\(cycles=\).*/\1$cycles/" -e "s/\(crit=\).*/\1$crit/" job ;;
		R)
				local wave cycles k1 isif ibrion nsw eqVol scale step
				echo -en "\nWrite wavefunction ( $(FC 2 1): y | 0: n ) -> "; read wave; set ${wave:=1}
				echo -n "Number of iterations ($(FC 2 1)) -> "; read cycles; set ${cycles:=1}
				echo -n "k-point ($(FC 2 1)) -> "; read k1; set ${k1:=1}
				echo -n "ISIF ($(FC 2 3)) -> "; read isif; set ${isif:=3}
				echo -n "IBRION ($(FC 2 2)) -> "; read ibrion; set ${ibrion:=2} 
				echo -n "NSW ($(FC 2 20)) -> "; read nsw; set ${nsw:=20} 
				echo -n "Equilibrium volume search ( 1: y | $(FC 2 0): n ) -> "; read eqVol; set ${egVol:=0}
				if [[ $eqVol == 1 ]]; then
					echo -n "Initial scale for volume ($(FC 2 1.00)) -> "; read scale; set ${scale:=1.00}
				  echo -n "Step size ($(FC 2 0.01)) -> "; read step; set ${step:=0.01}
					sed -i -e "s/\(eqVol=\).*/\1$eqVol/" -e "s/\(initScale=\).*/\1$scale/" -e "s/\(\tstep=\).*/\1$step/" job
				fi
				sed -i -e "s/^\(wave=\).*/\1$wave/" -e "s/^\(cycles=\).*/\1$cycles/" -e "s/^\(k1=\).*/\1$k1/" job
				sed -i -e "s/^\(isif=\).*/\1$isif/" -e "s/^\(ibrion=\).*/\1$ibrion/" -e "s/^\(nsw=\).*/\1$nsw/" job ;;
		SP)
				local l o
				echo -en "\nLocal potential ( 1: y | $(FC 2 0): n ) -> "; read l; if (( l == 1 )); then l=T; else l=F; fi; setTag LVTOT $l
				echo -n "Optical properties ( 1: y | $(FC 2 0): n ) -> "; read o; if (( o == 1 )); then o=T; else o=F; fi; setTag LOPTICS $o
				;;
		*)
			;;	
	esac
	name $x
	queue
	tLim
	nBands
	nPar
	cores
	nodes

	rm oldINCAR

	echo ""
}

nBands () { # set number of bands
	local bands term; term=0
	echo -n "Enter number of bands ($(storePos e) electrons; $(storePos i) ions) -> "; read bands
	if [[ ! $bands ]]; then
		if [ -f oldINCAR ]; then
			bands=$(getTag NBANDS oldINCAR)
		else
			echo -e "\nPrevious INCAR not found\n"; nBands; term=1
		fi
	fi
	if (( term == 0 )); then setTag NBANDS $bands; fi
}

nPar () { # set parallelization over bands
	local npar term; term=0
	echo -ne "Enter number of bands to run in parallel (NPAR) -> "; read npar
	if [[ ! $npar ]]; then
		if [ -f oldINCAR ]; then
 	   npar=$(getTag NPAR oldINCAR)
  	else
    	echo -e "\nPrevious INCAR not found\n"; nPar; term=1
  	fi
	fi
  if (( term == 0 )); then setTag NPAR $npar; fi
}

hybrid () { # turn hybrid on/off
	local hybrid hf
  echo -n "Hybrid funcational ( 1: On | $(FC 2 0): Off ) -> "; read hybrid
  if [[ $hybrid != 1 ]]; then
    setTag LHFCALC F
    disTag HFSCREEN TIME PRECFOCK NKRED AEXX
	else
    echo -n "Enter HF enxchange contribution ($(FC 2 0.25)) -> "; read hf
    if [ ! -f status ]; then setTag LWAVE T; fi
    setTag 'LHFCALC AEXX' "T $hf"
    enbTag HFSCREEN TIME PRECFOCK NKRED AEXX
  fi
}

uParam () { # turn DFT+U on/off

	# TO-DO: Allow for simultaneous multiple U parameters?

	local c s i u site orbit ul uu uj l
  echo -n "DFT+U ( 1: On | $(FC 2 0): Off ) -> "; read c
  if [[ $c != 1 ]]; then
		setTag LDAU F
    disTag LDAUTYPE LDAUL LDAUU LDAUJ LMAXMIX LASPH
    sed -i "s/DFT+U:.*/DFT+U:/" INCAR
	else
    s=($(storePos s))
    for i in ${!s[*]}; do s[$i]="$i-${s[$i]}"; done
    echo -n "Effective U -> "; read u
    echo -n "On which site? ( $(echo "${s[*]}" | sed 's/ / | /g') ) -> "; read site
    echo -n "On which orbital? ( 0-s | 1-p | 2-d | 3-f ) -> "; read orbit
    setTag 'LDAU LASPH' 'T T'
    enbTag LDAUTYPE LDAUL LDAUU LDAUJ LMAXMIX LASPH
	
    ul=(); uu=(); uj=()
    for i in ${!s[*]}; do
      if [[ $(echo ${s[$i]} | cut -c 1) == $site ]]; then
        ul=(${ul[*]} $orbit); uu=(${uu[*]} $(printf %0.1f $(echo "$u + 1" | bc))); uj=(${uj[*]} 1)
      else
        ul=(${ul[*]} -1); uu=(${uu[*]} 0); uj=(${uj[*]} 0)
      fi
    done

    setTag LDAUL "${ul[*]}"; setTag LDAUU "${uu[*]}"; setTag LDAUJ "${uj[*]}"
    case $orbit in 2) l=4;; 3) l=6;; *) l=2; setTag LASPH F; esac; setTag LMAXMIX $l
    sed -i "s/DFT+U:.*/DFT+U: $u/" INCAR
  fi
}

symmetry () { # turn symmetry on/off
	local s; echo -n "Symmetry ( 2: On | $(FC 2 0): Off ) -> "; read s; set ${s:=0}; setTag ISYM $s
}

spinPolar () {
	local sp; echo -n "Spin-polarized ( $(FC 2 1): On | 0: Off ) -> "; read sp; set ${sp:=1}; setTag ISPIN $((sp+1))
}

realProj () {
	local p
	echo -n "Projections in real space ( $(FC 2 1): On | 0: Off ) -> "; read p; set ${p:=1}
	if [[ $p == 1 ]]; then p=T; else p=F; fi; setTag LREAL $p
} 

magnetic () {
	local m; echo -n "Magnetic moment expected? ( 0: Yes | $(FC 2 1): No ) -> "; read m; set ${m:=1}; setTag NUPDOWN $((m-1)) 
}

SetUp () { # define initial job settings
	local s f
  s=$(head -6 POSCAR | tail -1 | rmSpace)
	if [ $1 ]; then f=$1; else f=2; fi
  potGen $f $s
	if [ -s POTCAR ]; then
	  hybrid
	  uParam
		spinPolar
	  symmetry
		realProj
		magnetic
	  echo ""
	fi
}

potGen () { # generate POTCAR

	local func dir opts

  gen() {
		local elements i 
    if [[ $1 ]]; then
      elements=$*
    else
      echo -ne "\nEnter system elements -> "
        read elements
    fi
    for i in $elements; do
      if [[ ! $(grep "^ $pat $i[_ ]" $dir) ]]; then
        echo -e "\nOne or more of the elements does not exist!"; gen $*
			else
			  sed -n "/^ $pat $i[_ ]/,/End/p" $dir >> POTCAR
      fi
    done
  }

# define location of POTCAR database (LDA | GGA | PBE)
	if [ -f POTCAR ]; then rm POTCAR; fi
	if [[ ! $1 ]]; then echo -ne "\nFunctional ( 0: LDA | 1: GGA | $(FC 2 2): PBE ) -> "; read func; set ${func:=2}; else func=$1; fi
	case $func in
		0) dir=/work/01293/hudamn/Edan/PAW_LDA; pat=PAW ;; 
		1) dir=/work/01293/hudamn/Edan/PAW_GGA; pat=PAW ;;
		2) dir=/work/01293/hudamn/Edan/PAW_PBE; pat=PAW_PBE ;;
		*) echo -e "\nUsage: potGen <0: LDA | 1: GGA | 2: PBE> <element list>\n"; return
	esac

# generate POTCAR
  opts=($*)
  gen ${opts[*]:1}

# verify POTCAR
	echo ""
	grep "^ $pat [A-Z]" POTCAR
  echo ""
}
